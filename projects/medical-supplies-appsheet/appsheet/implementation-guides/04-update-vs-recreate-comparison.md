# 在庫変動履歴の更新方式比較：上書き vs 削除→新規作成

## 結論：削除→新規作成を推奨

## 比較表

| 観点 | 上書き（UPDATE） | 削除→新規作成（DELETE+ADD） |
|------|-----------------|---------------------------|
| アクション再利用 | ❌ 編集専用アクションが必要 | ✅ 新規作成アクションを再利用可能 |
| 実装の複雑さ | ❌ 各フィールドの差分計算が必要 | ✅ シンプル（完全な値を記録） |
| 保守性 | ❌ 複数のアクション管理 | ✅ 統一されたアクション |
| テスト | ❌ 更新パターンごとにテスト必要 | ✅ 新規作成のテストのみ |
| パフォーマンス | ✅ 1ステップ | ⚠️ 2ステップ（影響は軽微） |
| ID保持 | ✅ IDが変わらない | ⚠️ 新しいIDになる |
| データ整合性 | ⚠️ 部分更新によるリスク | ✅ 完全な置き換えで安全 |

## 削除→新規作成が推奨される理由

### 1. アクション再利用による開発効率

```
既存アクション: Create_Inventory_History
- 入荷追加時：このアクションを使用
- 配布追加時：このアクションを使用
- 編集時：削除後、同じアクションを使用 ← 再利用！
```

上書きの場合：
```
必要なアクション数:
- Create_Inventory_History（新規用）
- Update_Inventory_History_Receipt（入荷編集用）
- Update_Inventory_History_Distribution（配布編集用）
- Update_Inventory_History_StockTake（棚卸編集用）
→ 管理するアクションが4倍に！
```

### 2. 実装のシンプルさ

**削除→新規作成の実装**：
```
Step 1: 古いレコードを削除
  DELETE WHERE [入荷ID] = [_THISROW].[入荷ID]

Step 2: 新しいレコードを作成（既存アクション呼び出し）
  CALL Create_Inventory_History
```

**上書きの実装**（複雑）：
```
UPDATE SET
  変動日 = IF([変動日] <> [_THISROW].[入荷日], [_THISROW].[入荷日], [変動日]),
  変動数量_箱 = [変動数量_箱] - [_THISROW_BEFORE].[入荷数量_箱] + [_THISROW].[入荷数量_箱],
  変動数量_個 = [変動数量_個] - [_THISROW_BEFORE].[入荷数量_個] + [_THISROW].[入荷数量_個],
  ... // 各フィールドごとに差分計算
```

### 3. データの一貫性

削除→新規作成では「常に完全で正しいデータを記録」という単純な原則：
- 編集前の状態を考慮不要
- 現在の値をそのまま記録
- 計算ミスのリスクが低い

### 4. 在庫変動履歴の特性に適合

在庫変動履歴は「ログ」的な性質：
- 他のテーブルから参照されることが少ない
- IDが変わっても実質的な影響なし
- 重要なのは「正確な履歴」であってIDではない

## IDが変わることの影響評価

### 影響が少ない理由

1. **参照関係**
   - 在庫変動履歴 → 他テーブル：参照あり（入荷ID、配布ID等）
   - 他テーブル → 在庫変動履歴：参照なし（ログなので）

2. **レポート・分析**
   - 集計は日付や商品IDベースで行う
   - 個別の履歴IDを追跡することは稀

3. **監査証跡**
   - 削除→新規作成でも「いつ誰が変更したか」は記録される
   - 必要なら変更履歴専用テーブルで補完

## 実装例

### Automationボットの構成

```yaml
Bot: Handle_Receipt_Edit
  Event: 入荷記録.UPDATES
  Process:
    - Action: Delete_Inventory_History
      Filter: [入荷ID] = [_THISROW].[入荷ID]

    - Action: Create_Inventory_History  # 既存アクション再利用
      Values:
        変動日: [_THISROW].[入荷日]
        商品ID: [_THISROW].[商品ID]
        変動数量_箱: [_THISROW].[入荷数量_箱]
        ...
```

### テストケース

削除→新規作成の場合：
1. 新規作成のテスト（完了済み）
2. 削除のテスト
→ 2種類のテストで完了

上書きの場合：
1. 各フィールドの更新テスト
2. 複数フィールド同時更新テスト
3. 境界値テスト
4. NULL値の扱い
→ テストケースが膨大

## まとめ

**削除→新規作成方式**を推奨：

✅ **開発効率**：アクション再利用で実装が速い
✅ **保守性**：統一されたアクションで管理が楽
✅ **信頼性**：シンプルな実装でバグが少ない
✅ **拡張性**：新しいフィールド追加時も対応が簡単

ID変更のデメリットは、在庫変動履歴の性質上、実質的な影響がほとんどないため、メリットの方が大きく上回ります。